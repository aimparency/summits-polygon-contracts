#2022-06-14
- 

#2022-06-11
- Wohin mit den Flows? 
  - hmmm...
  - erstmal bei den into-aims 
  - und dann vielleicht approvals auf der from-Seite
    - nur approvte aims werden in clients geladen
    - sonst gingen von Elon Musks Ideen tausende fan-pfeile ab
    - ein filter wäre auch möglich, dass nur aims geladen werden, 
      - die mindestens x% so groß sind wie der Parent
  - der share wird ja auch beim into-aim festgelegt
    - pfeilrichtung = "contribute"
    - importance fließt entgegen der Pfeilrichtung

- Kompilieren & local deployen 
  - einen test schreiben vielleicht? :) 

#deployment
- generate 0x0000....* vanity address
  - vanityeth -i 00000 --contract
- deploy 
  - so wählen, als hätte ich 1337 ETH ausgegeben. 
  - anders: ich will es wirklich selbst kaufen. 
    - Ich habe 10k, die ich da investieren kann
    - 10k (scheiße, mein NEAR ist wirklich nur noch 10k wert...) 
      - Ich glaube, ich muss bald mal wieder EUR verdienen..
      - Aber vielleicht halte ich auch so durch :) 
    - All mein crypto nach ETH
      - also sagen wir mal, ich kriege 8 ETH zusammen
      - 8 ETH... wie viele coins sind das dann? 
        - x ^ 2 = 4ETH = 4 * 10**18
        - x = 2 * 10**9 

#2022-06-08

- subgraph implementieren 

- efforts als Zahl einfach (Im frontend wird dann geparsed. 5 years 2 months) 

- status + completion

- switch to 0.8.14

- Bonding curve

- Frontend / GraphQL: Date (created + last change + show history vielleicht?)

- EIP-1167
  - Base Contract ( = summits selbst? ) 
  - Factory 
  - Clonse (Proxy/Instances) 

- Am Anfang immer Bonding curve
  - Ein Teil davon geht an uns? oder nicht... (lieber nicht, ist einfacher. Und ich versuche nicht, etwas für mich zu sichern. Ich habe einfach Spaß am Leben. Jeder, der versucht, sich selbst mehr zu sichern, stirbt daran) 
  - Optout => zu einem anderen ERC20 Token
    - Freeze die Bonding curve
    - Frontend kann dann Link zu UniSwap anzeigen oder so
    
- Aim = Base Contract
  - create
  - set content

- speichere nur diffs
  - und zwar an eine bestimmte Stelle: [4] 
    - wenn sie schon existiert, wird der change abgewiesen, um Kollisionen zu vermeiden
  - und dann noch lzma drüber laufen lassen 
    - falls es komprimiert kleiner ist, mit dem ersten byte anzeigen, dass es komprimiert ist

- will ich IPFS-Kram supporten? 
  - ich denke schon...
  - aber das ist wieder ne nummer größer... 
  - Ach, ich brauche erstmal keine Images
  - Und notizen packe ich wirklich auf die chain. 
  - Ich glaube ich spare mir den IPFS-Kram
  - Aber ein Subgraph schreibe ich, um gescheit requesten zu können. 

